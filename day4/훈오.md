## 2-14(ì œë„¤ë¦­)

### ì œë„¤ë¦­ì´ë€?

íƒ€ì… ê°„ì— ì¤‘ë³µë˜ëŠ” ë¶€ë¶„ì„ ì—†ì• ê³  í•˜ë‚˜ì˜ íƒ€ì…ì„ ì—¬ëŸ¬ ë°©ë²•ìœ¼ë¡œ ì¬ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ í•´ì£¼ëŠ” ì†ì„±

- ì¸í„°í˜ì´ìŠ¤
  ```jsx
  interface Zero{
  type: "human",
  race: "yellow",
  name: "zero",
  age: 28
  }

  inteface Nero{
  type: "human",
  race: "yellow".
  name: "nero",
  age: 32
  }
  ```
  `Zero` íƒ€ì…ê³¼ `Nero` íƒ€ì…ì€ `type`ê³¼ `race` ì†ì„±ì˜ íƒ€ì…ì´ ì¤‘ë³µë˜ê³ , `name` ê³¼ `age` ì†ì„±ì˜ íƒ€ì…ì´ ë‹¤ë¥´ë‹¤.
  ```jsx
  interface Person<N, A> {
  	type: "human";
  	race: "yellow";
  	name: N;
  	age: A;
  }

  interface Zero extends Person<"zero", 28> {}
  interface Nero extends Person<"nero", 32> {}
  ```
  ì œë„¤ë¦­ì„ ì‚¬ìš©í•˜ë©´ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ë“¯ì´ íƒ€ì… ì¸ìˆ˜ë¥¼ ë°›ì•„ì„œ ë™ì ìœ¼ë¡œ ì†ì„±ì˜ íƒ€ì…ì„ ì •í•´ì¤„ ìˆ˜ ìˆë‹¤.
- íƒ€ì…ë³„ì¹­
  ```jsx
  type Person<N, A> = {
  type:"human",
  race:"yellow",
  name:N,
  age:A
  }

  type Zero = Person<"zero", 28> {}
  type Nero = Person<"nero", 32> {}
  ```
- í´ë˜ìŠ¤
  ```jsx
  class Person<N, A> {
  	name: N
  	age: A

  	constructor(name: N, age: A) {
  		this.name = name
  		this.age = age
  	}
  }
  ```
- í•¨ìˆ˜
  - ì„ ì–¸ë¬¸
    ```jsx
    const personFactoryE = <N, A>(name: N, age: A) => ({
    	type: "hunan",
    	race: "yellow",
    	name,
    	age,
    })
    ```
  - í‘œí˜„ì‹
    ```jsx
    function personFactoryD<N, A>(name: N, age: A) {
    	return {
    		type: "hunan",
    		race: "yellow",
    		name,
    		age,
    	}
    }
    ```
- ê°ì²´ë‚˜ í´ë˜ìŠ¤ì˜ ë©”ì„œë“œì— ë”°ë¡œ ì œë„¤ë¦­ í‘œê¸°
  ```jsx
  class Person<N, A> {
  	name: N
  	age: A
  	constructor(name: N, age: A) {
  		this.name = name
  		this.age = age
  	}
  	method<B>(param: B) {}
  }
  ```
- ë§¤ê°œë³€ìˆ˜ ê¸°ë³¸ ê°’
  ```jsx
  interface Person<N = string, A = number> {
  	type: "human";
  	race: "yellow";
  	name: N;
  	age: A;
  }

  type Person1 = Person
  type Person2 = Person<number>
  type Person3 = Person<number, boolean>
  ```
  í•¨ìˆ˜ì— ë§¤ê°œë³€ìˆ˜ ê¸°ë³¸ê°’ì„ ì§€ì •í•˜ë“¯ì´ íƒ€ì…ë„ ë§¤ê°œë³€ìˆ˜ì˜ ê¸°ë³¸ íƒ€ì…ì„ ì§€ì •í•  ìˆ˜ ìˆìœ¼ë©° ìœ„ì˜ ì˜ˆì‹œì—ì„œ ì¸ìê°€ ë‘ê°œì¼ë•Œ ì¸ìë¥¼ í•˜ë‚˜ë§Œ ë„£ìœ¼ë©´ ë‘ê°œì— ëŒ€í•´ì„œ ëª¨ë‘ íƒ€ì… ì§€ì •ì´ ëœë‹¤.
  **ì‚¬ì‹¤, ì´ë ‡ê²Œ ì œë„¤ë¦­ì— ì§ì ‘ íƒ€ì…ì„ ë„£ì§€ ì•Šì•„ë„ ì¶”ë¡ ì„ í†µí•´ íƒ€ì…ì„ ì•Œì•„ë‚´ëŠ” ê²ƒì´ ì¼ë°˜ì ì´ë‹¤.**
  ```jsx
  interface Person<N, A> {
  	type: "human";
  	race: "yellow";
  	name: N;
  	age: A;
  }

  const personFactoryE = <N, A = unknown>(name: N, age: A): Person<N, A> => ({
  	type: "human",
  	race: "yellow",
  	name,
  	age,
  })

  const zero = personFactoryE("zero", 28)
  ```
  ì œë„¤ë¦­ì„ ë„£ì–´ì£¼ì§€ ì•Šì•„ë„ íƒ€ì…ì¶”ë¡ ì„ í†µí•´ ìë™ìœ¼ë¡œ zeroì˜ íƒ€ì…ì€ `Person<string, number>`ê°€ ëœë‹¤.
- ìƒìˆ˜ íƒ€ì… ë§¤ê°œë³€ìˆ˜(5.0)
  ```jsx
  function values<T>(initial: T[]) {
  	return {
  		hasValue(value: T) {
  			return initial.includes(value)
  		},
  	}
  }

  const savedValues = values(["a", "b", "c"])
  savedValues.hasValue("x")
  ```
  `T`ì˜ íƒ€ì…ì€ ìì—°ìŠ¤ë ˆ `string` ìœ¼ë¡œ ì¶”ë¡ ì´ ë˜ëŠ”ë° ë§Œì•½ ë‚´ê°€ ì£¼ì…í•œ íƒ€ì…ë“¤ë¡œ ì´ë£¨ì–´ì§„ ìœ ë‹ˆì˜¨ íƒ€ì…ìœ¼ë¡œë§Œ íƒ€ì…ì´ ì§€ì •ë˜ê²Œ í•˜ë ¤ë©´ ì–´ë–»ê²Œ í•´ì•¼í• ê¹Œ?
  ```jsx
  function values<T>(initial:readonly T[]){
    return {
      hasValue(value:T){return initial.includes(value)}
    }
  }

  const savedValues = values(["a","b","c"] as const)
  savedValues.hasValue("x") // Error
  ```
  `as const` ì ‘ë¯¸ì‚¬ë¥¼ í†µí•´ [â€aâ€,â€bâ€,â€câ€]ë¥¼ íŠœí”Œë¡œ ë§Œë“¤ê³ , ë§¤ê°œë³€ìˆ˜ì— `readonly` ë¥¼ ë¶™ì—¬ì¤˜ì„œ í•´ê²°í•œë‹¤.
  ```jsx
  function values<const T>(initial:readonly T[]){
  }
  ```
  í•˜ì§€ë§Œ, 5.0 ë²„ì „ë¶€í„°ëŠ” ë” ê°„í¸í•˜ê²Œ ì œë„¤ë¦­ ì•ˆì—ì„œ `const`ë¥¼ ì•ì— ë¶™ì´ë©´ ëœë‹¤.

### ì œë„¤ë¦­ì— ì œì•½ ê±¸ê¸°

íƒ€ì… ë§¤ê°œë³€ìˆ˜ì˜ íƒ€ì…ì„ ì œì•½ì„ ê±¸ ìˆ˜ ìˆë‹¤.

```jsx
interface Example<A extends number, B=string>{
  a:A,
  b:B
}

type Usecase1 = Example<1,boolean>
type Usecase2 = Example<number,boolean>
type Usecase3 = Example<string,boolean> // Error
```

ë§¤ê°œë³€ìˆ˜ ê¸°ë³¸ ê°’ê³¼ í—·ê°ˆë¦´ ìˆ˜ ìˆì§€ë§Œ ìœ„ì˜ ì˜ˆì‹œì—ì„œ ì œì•½ì„ ê±¸ë©´ Aì— ëŒ€í•œ íƒ€ì…ìœ¼ë¡œ `number` ë˜ëŠ” ê·¸ë³´ë‹¤ ì¢ì€ íƒ€ì…ì¸ ë¦¬í„°ëŸ´ íƒ€ì…ë§Œ í—ˆìš©í•œë‹¤.

```jsx
interface Example<A, B extends A>{
  a:A,
  b:B
}

type Usecase1 = Example<1,1>
type Usecase2 = Example<number,1>
type Usecase3 = Example<string,"1">
type Usecase4 = Example<string,1> // Error
```

í•˜ë‚˜ì˜ íƒ€ì… ë§¤ê°œë³€ìˆ˜ê°€ ë‹¤ë¥¸ íƒ€ì… ë§¤ê°œë³€ìˆ˜ì˜ ì œì•½ì´ ë  ìˆ˜ ë„ ìˆë‹¤.

ì„ ì–¸í• ë•ŒëŠ” Aíƒ€ì…ê³¼ Bíƒ€ì…ì— ëŒ€í•´ì„œ ì •ë³´ê°€ ì—†ì§€ë§Œ ì‚¬ìš©í•˜ëŠ” ê³³ì—ì„œ A íƒ€ì…ì„ ë„£ìŒì— ë”°ë¼ Bíƒ€ì…ë„ êµ¬ì²´ì ìœ¼ë¡œ ì •í•´ì§€ê²Œ ëœë‹¤.

```jsx
<T extends object> // ëª¨ë“  ê°ì²´
<T extends any[]> // ëª¨ë“  ë°°ì—´
<T extends (...args:any)=>any> // ëª¨ë“  í•¨ìˆ˜
<T extends abstract new (...args: any)=>any> // ìƒì„±ì íƒ€ì…
<T extends keyof any> // string | number | symbol
```

ìœ„ì™€ ê°™ì€ ì œì•½ì´ ìì£¼ ì“°ì¸ë‹¤ê³  í•œë‹¤.

**ì£¼ì˜í•´ì•¼ í•  ì ì€ íƒ€ì… ë§¤ê°œë³€ìˆ˜ì™€ ì œì•½ì„ ë™ì¼ì‹œí•˜ì§€ ì•ŠëŠ” ê²ƒì´ë‹¤.**

```jsx
interface V0{
  value: any
}

const returnV0 = <T extends V0>(): T=>{
  return {value: "test"} // Error
}
```

íƒ€ì… `T` ëŠ” `V0` ê°€ ì•„ë‹Œ `V0`ë¥¼ í™•ì¥í•œ íƒ€ì…ì´ì–´ì•¼ í•˜ë¯€ë¡œ ë°˜í™˜í•œ íƒ€ì…ì€ `T`ê°€ ì•„ë‹Œ `V0` ê°€ ë˜ë¯€ë¡œ ì—ëŸ¬ê°€ ë°œìƒí•œë‹¤.

ëª…ì‹¬í•˜ì. ì—¬ê¸°ì„œ `T`ëŠ” `V0` ì— ëŒ€ì…í•  ìˆ˜ ìˆëŠ” ëª¨ë“  íƒ€ì…ì„ ë§í•œë‹¤.

```jsx
// Error
function onlyBoolean<T extends boolean>(arg: T=false):T{
  return arg;
}
```

`T`ê°€ `never`ê°€ ë˜ëŠ” ê²½ìš°ì— `never extends boolean`ì€ í•­ìƒ ì°¸ì´ë¯€ë¡œ `false`ë¥¼ ê¸°ë³¸ê°’ìœ¼ë¡œ ë„£ëŠ” ê²ƒì´ ë¶ˆê°€ëŠ¥í•˜ë‹¤.

**ë”°ë¼ì„œ, íƒ€ì… ë§¤ê°œë³€ìˆ˜ê°€ ì œì•½ì— ëŒ€ì…í•  ìˆ˜ ìˆëŠ” íƒ€ì…ì¸ì§€ë¥¼ ë”°ì ¸ë´ì•¼í•œë‹¤.**

**í•´ê²°ì±…ì€ ê·¸ëƒ¥ ì œë„¤ë¦­ì„ ì•ˆì“°ë©´ ëœë‹¤.**

```jsx
function onlyBoolean(arg: true | false = true): true | false {
	return arg
}

interface V0 {
	value: any;
}

const f = (): V0 => {
	return {value: "test"}
}
```

ì›ì‹œê°’ íƒ€ì…ë§Œ ì‚¬ìš©í•œë‹¤ë©´ ëŒ€ë¶€ë¶„ì˜ ê²½ìš° ì œì•½ì„ ê±¸ì§€ ì•Šì•„ë„ ëœë‹¤.

## ì»¨ë””ì…”ë„ íƒ€ì…

ì¡°ê±´ì— ë”°ë¼ ë‹¤ë¥¸ íƒ€ì…ì´ ë  ìˆ˜ ìˆê²Œ í•˜ëŠ” ì»¨ë””ì…”ë„ íƒ€ì…ì´ ìˆë‹¤.

```jsx
type A1 = string
type B1 = A1 extends string ? number :boolean
```

`extends` ì˜ˆì•½ì–´ë¥¼ í†µí•´ ì´ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì™¼ìª½ì— ìˆëŠ” íƒ€ì…ì´ ì˜¤ë¥¸ìª½ì— ìˆëŠ” íƒ€ì…ì— ëŒ€ì…ì´ ê°€ëŠ¥í•˜ë©´ ì°¸ìœ¼ë¡œ íŒë‹¨í•œë‹¤. ë”°ë¼ì„œ ìœ„ì˜ ì˜ˆì‹œì—ì„œëŠ” `B1` ì˜ íƒ€ì…ì€ `number`ê°€ ëœë‹¤.

**ì»¨ë””ì…”ë„ íƒ€ì…ì€ íƒ€ì„ê²€ì‚¬ì—ì„œë„ ë§ì´ ì´ìš©ëœë‹¤.**

```jsx
type Result = 'h1' extends string? true: false
type Result2 = [1] extends [string] ? true : false
```

ìœ„ì™€ ê°™ì´ íƒ€ê²Ÿì´ íŠ¹ì • íƒ€ì…ì„ ê°€ì§€ëŠ”ì§€ ì•„ë‹Œì§€ ì•Œ ìˆ˜ ìˆë‹¤.

```jsx
type ChooseArray<A> = A extends string ? string[] : never
type StringArray = ChooseArray<string>
type Never = ChooseArray<number>
```

ë˜í•œ, `never` íƒ€ì…ê³¼ ê°™ì´ ì‚¬ìš©ë˜ëŠ” ê²½ìš°ë„ ë§ë‹¤.

```jsx
type OmitByType<O,T>={
  [K in keyof O as O[K] extends T ? never : K]:O[K]
}

type Result = OmitByType<{
  name:string
  age:number
  married:boolean
  rich:boolean
},boolean>
```

ë§¤í•‘ëœ ê°ì²´ íƒ€ì…ì—ì„œ `never` íƒ€ì…ì˜ í‚¤ë¥¼ ì œê±°í•˜ë„ë¡ í•  ìˆ˜ ìˆë‹¤.

ìµœì¢…ì ìœ¼ë¡œ ë§Œë“¤ì–´ì§„ `Result` íƒ€ì…ì€ `name`ê³¼ `age` ì†ì„±ë§Œ ì¡´ì¬í•œë‹¤.

```jsx
type A1 = string
type B1 = A1 extends string ? number: boolean
type B2 ={
  't':number,
  'f':boolean
}[A1 extends string? "t" :"f"]
```

ì¸ë±ìŠ¤ ì ‘ê·¼ íƒ€ì…ìœ¼ë¡œë„ ì»¨ë””ì…”ë„ íƒ€ì…ì„ í‘œí˜„í•  ìˆ˜ ìˆë‹¤.

B1ê³¼ B2ëŠ” ì‚¬ì‹¤ ê°™ì€ë° ì°¸ì´ë‚˜ ê±°ì§“ì¼ë•Œ íƒ€ì…ì´ ë³µì¡í•œê²½ìš° ìœ„ì™€ ê°™ì´ ë‚˜íƒ€ë‚¸ ë‹¤ê³  í•œë‹¤. ì•„ë§ˆ ê°€ë…ì„± ë•Œë¬¸ì¼ ê²ƒ ê°™ë‹¤.

### ì»¨ë””ì…”ë„ íƒ€ì… ë¶„ë°°ë²•ì¹™

ì»¨ë””ì…”ë„ íƒ€ì…, ì œë„¤ë¦­ê³¼ neverì˜ ì¡°í•©ì€ **ë” ë³µì¡í•œ ìƒí™©**ì—ì„œ ì§„ê°€ë¥¼ ë°œíœ˜í•œë‹¤.

```jsx
type Start = string | number
type Result = Start extends string ? Start[] : never
```

`string | number` íƒ€ì…ìœ¼ë¡œë¶€í„° `string[]` íƒ€ì…ì„ ì–»ê³  ì‹¶ì€ ìƒí™©ì´ì§€ë§Œ `never`ê°€ ë˜ì–´ë²„ë¦°ë‹¤.

ì´ë•Œ ì œë„¤ë¦­ì„ ì‚¬ìš©í•´ í•´ê²°í•  ìˆ˜ ìˆë‹¤.

```jsx
type Start = string | number
type Result<Key> = Key extends string ? Key[] : never
let n:Result<Start>=['hi']
```

**ê²€ì‚¬í•˜ë ¤ëŠ” íƒ€ì…ì´ ì œë„¤ë¦­ì´ë©´ì„œ ìœ ë‹ˆì–¸ì´ë©´ ë¶„ë°°ë²•ì¹™ì´ ì‹¤í–‰ë˜ëŠ” íŠ¹ì´í•œ ì„±ì§ˆì´ ìˆë‹¤.**

ì¦‰, `Result<string | number>` â‡’ `Result<string> | Result<number>` ê°€ ë˜ê³ , ê°ê° `Key`ì— ë„£ì–´ì„œ ë¹„êµí•˜ë©´ `string [] | never` íƒ€ì…ì´ ë¼ì„œ `string[]` ì´ ëœë‹¤.

í•˜ì§€ë§Œ, `boolean`ì— ë¶„ë°°ë²•ì¹™ì„ ì ìš©í• ë•ŒëŠ” ì¡°ì‹¬í•´ì•¼ í•œë‹¤.

```jsx
type Start = string | number | boolean
type Result<Key> = Key extends string | boolean ? Key[] : never
let n : Result<Start> = ["hi"]
n=[true]
```

`n`ì˜ ì˜ˆìƒë˜ëŠ” íƒ€ì…ì€ `string[] | boolean[]` ì´ì§€ë§Œ ì‹¤ì œë¡œëŠ” `string[] | false[] | true[]` ì´ë‹¤.

`boolean` ìì²´ë„ `true | false`ë¡œ ì¸ì‹í•˜ê¸° ë•Œë¬¸ì´ë‹¤.

ì´ ë•Œë¬¸ì— ì¼ì–´ë‚˜ëŠ” ë¬¸ì œê°€ ë˜ ìˆë‹¤.

```jsx
type IsString<T> = T extends string? true :false
type Result = IsString<"hi" | 3>
```

ì˜ˆìƒëŒ€ë¡œë¼ë©´ 3ì€ `string` ì´ ì•„ë‹ˆë¼ì„œ `false`ê°€ ë‚˜ì™€ì•¼ í•œë‹¤.

í•˜ì§€ë§Œ, ë¶„ë°°ë²•ì¹™ì— ì˜í•´ `true | false`ê°€ ë˜ë¯€ë¡œ `boolean`ì´ ë‚˜ì˜¤ê²Œ ëœë‹¤.

**ê·¸ë ‡ë‹¤ë©´ ë¶„ë°°ë²•ì¹™ì´ ì¼ì–´ë‚˜ì§€ ì•Šê²Œ í•˜ëŠ” ë²•ì€ ë­˜ê¹Œ?**

**ë°°ì—´ë¡œ ì œë„¤ë¦­ì„ ê°ì‹¸ë©´ ëœë‹¤.**

```jsx
type IsString<T> = [T] extends [string]? true :false
type Result = IsString<"hi" | 3>
```

`['hi' | 3]` ì´ `[string]` ì„ `extends` í•˜ì§€ëŠ” ëª»í•˜ë‹ˆê¹Œ `false`ê°€ ëœë‹¤.

**ë˜ í•œê°€ì§€ ì¤‘ìš”í•œ ì ì€ `never` íƒ€ì…ë„ ë¶„ë°°ë²•ì¹™ì˜ ëŒ€ìƒì´ ëœë‹¤ëŠ” ê²ƒì´ë‹¤. ìœ ë‹ˆì–¸ìœ¼ë¡œ ë³´ì´ì§€ëŠ” ì•Šì§€ë§Œ ìœ ë‹ˆì–¸ìœ¼ë¡œ ìƒê°í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤.**

<aside>
ğŸ’¡ `never` **íƒ€ì…ì´ ìœ ë‹ˆì˜¨ íƒ€ì…ì´ë¼ëŠ” ê²ƒì´ ì´í•´ê°€ ì•ˆê°€ì„œ ê²€ìƒ‰í•´ë´¤ëŠ”ë° ì‹¤ì œë¡œëŠ” ìœ ë‹ˆì˜¨ íƒ€ì…ì´ ì•„ë‹ˆì§€ë§Œ ê³µì§‘í•©ê³¼ ë¹„ìŠ·í•œ ê°œë…ì´ë¼ì„œ ê·¸ë ‡ê²Œ ìƒê°í•´ë„ ëœë‹¤ëŠ”ë° ì˜ ì´í•´ê°€ ê°€ì§€ ì•ŠëŠ”ë‹¤.**

</aside>

```jsx
type R<T> =T extends string ? true : false
type RR = R<never>
```

`never`ëŠ” ê³µì§‘í•©ì´ë¯€ë¡œ ì•„ë¬´ê²ƒë„ ì‹¤í–‰í•˜ì§€ ì•Šì•„ íƒ€ì… ê²°ê³¼ëŠ” `true`ê°€ ì•„ë‹Œ `never`ê°€ ëœë‹¤.

**ê°„ë‹¨í•˜ê²Œ ì»¨ë””ì…”ë„ íƒ€ì…ì—ì„œ ì œë„¤ë¦­ê³¼ `never`ê°€ ë§Œë‚˜ë©´ `never`ê°€ ëœë‹¤ëŠ” ê²ƒì„ ê¸°ì–µí•˜ì.**

ë”°ë¼ì„œ, `never`ë¥¼ íƒ€ì… ì¸ìˆ˜ë¡œ ì‚¬ìš©í•˜ë ¤ë©´ ë¶„ë°°ë²•ì¹™ì„ ë§‰ì•„ì•¼ í•œë‹¤.

```jsx
type IsNever<T> = [T] extends [never] ? true : false
type T = IsNever<never>
type F = IsNever<'never'>
```

ê°™ì€ ì´ìœ ë¡œ ì œë„¤ë¦­ê³¼ ì»¨ë””ì…”ë„ íƒ€ì…ì„ ê°™ì´ ì‚¬ìš©í• ë•ŒëŠ” ë‹¤ìŒì„ ì¡°ì‹¬í•´ì•¼ í•œë‹¤.

```jsx
function test<T>(a:T){
  type R<T> = T extends string ? T : T
  const b:R<T>=a
}
```

`R<T>` ê°€ `T`ê°€ ë ê²ƒì´ë¼ê³  ì˜ˆìƒì´ ë˜ì§€ë§Œ **íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ëŠ” ì œë„¤ë¦­ì´ ë“¤ì–´ ìˆëŠ” ì»¨ë””ì…”ë„ íƒ€ì…ì„ íŒë‹¨í•  ë•Œ ê°’ì˜ íŒë‹¨ì„ ë’¤ë¡œ ë¯¸ë£¨ê¸° ë•Œë¬¸ì—** Të¥¼ R<T>ì— ëŒ€ì…í•˜ì§€ ëª»í•œë‹¤.

```jsx
function test<T>(a:T){
  type R<T> = [T] extends [string] ? T : T
  const b:R<T>=a
}
```

ì—­ì‹œë‚˜ íŒë‹¨ì„ ë’¤ë¡œ ë¯¸ë£¨ì§€ ëª»í•˜ë„ë¡ ë°°ì—´ë¡œ ì œë„¤ë¦­ì„ ê°ì‹¸ì„œ í•´ê²°í•˜ë©´ ëœë‹¤.

## ë§ˆì¹˜ë©°

ì œë„¤ë¦­ì„ ì²˜ìŒìœ¼ë¡œ ì œëŒ€ë¡œ í•™ìŠµí•´ë´¤ëŠ”ë° ìƒë‹¹íˆ ì–´ë ¤ìš´ ê²ƒ ê°™ë‹¤.. ì¡°ê¸ˆë§Œ ë³µì¡í•´ì ¸ë„ ì–´ë ¤ì›Œì„œ ìµìˆ™í•´ì§€ëŠ”ë° ì¢€ ì˜¤ë˜ ê±¸ë¦´ ê²ƒ ê°™ë‹¤.
